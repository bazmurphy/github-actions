# Job Artifacts & Outputs

## Module Introduction

![](images/05-01.png)

## Demo Project Setup

-

## Understanding Job Artifacts

![](images/05-02.png)

- Job Artifacts

- When we run a Job, Examples:

  - Building a Website produces a build/dist folder
  - Building a Mobile App produces a Package to upload to an App Store
  - Building an Desktop App produces an Binary Executable

- We generate some assets that we upload somewhere
- These assets are generally called Job Artifacts
- A Job Artifact is the Output/Assets generated by a Job

- With GitHub Actions we can save those Artifacts

  - We can download them manually
  - We can download them automatically and use them in other Jobs

- It doesn't have to be just binaries, it can also be log files etc.
- But they are files/folders produced by a Job that we want to use in other Jobs or manually inspect

## Artifacts - An Example

- When we run `npm run build` for example it produces a `/dist` folder

- It would be useful if we could store and use those produced folders/files

- Well we can store them and access with GitHub Actions

- This `/dist` folder is the Artifact produced by the `build` Job

## Uploading Job Artifacts

- To store the Artifact we add a new Step

- We use an Action `actions/upload-artifact@v3`
  https://github.com/actions/upload-artifact

- `name` is required, we use it to retrieve the artifact later
- `path` is required, to tell it which files/folders to store

```yml
steps:
  # This allows us to Upload Artifacts
  - name: Upload Artifacts
    uses: actions/upload-artifact@v3
    with:
      # we give the Artifact a name, so we can retrieve it later
      name: dist-artifact
      # this defines which files you want to store
      path: dist
```

- Now when we run this Workflow, if we visit the Workflow that was run on GitHub, the artifacts are available at to manually download

## Downloading Artifacts (Manually & Automatically)

- Each Job is run on its own Runner, the Artifact produced in the `build` Job will not automatically exist in the `deploy` Job.
- So if we want to use the Artifact created in the `build` Job in the `deploy` Job, we need a way of getting a hold of the Artifact.
- In order to get those Artifacts we need to download them using an Action
- Download Artifact Action https://github.com/actions/download-artifact

- We must provide a `with` and a `name` that references the Artifact identifier (in this case from the `build` Job above)

- NOTE: It unzips the Artifact, but WITHOUT the original folder, so the files will not be inside a `dist` folder but in the root of the default directory

```yml
steps:
  - name: Download Artifacts
    uses: actions/download-artifact@v3
    with:
      # we need to provide the Artifact identifier
      name: dist-artifact
```

## Understanding Job Outputs

![](05-03.png)

- Jobs can also produce/provide Outputs
  - a simple value (a number, or some text, etc) produced by the Job (that should be accessible by other Jobs)
  - typically used for reusing a value in different Jobs
  - example: the name of a file used in a previous `build` Step

## Job Outputs - An Example

- For a contrived example, We will try to get the name of the javascript file in the `/assets` folder because it's randomly generated
- We can get the name in the `build` Job and make it available in the `deploy` Job
- So we have one Value that is made by one Job and use it in another Job

- We need to use another keyword `outputs` and it must be BEFORE `steps`
- Provide a name/identifier for our output eg. `javascript-file`
- And the value uses GitHub Actions Context `steps.(id of the step).outputs.(key name)`

```yml
# We define the Outputs
outputs:
  # We give it an identifier and use the GitHub Actions Context
  # Using steps.(id of the step).outputs.(key name)
  javascript-file: ${{ steps.publish.outputs.javascript-file }}
```

- We then get the name of the javascript file from the assets folder using a linux shell command

```yml
steps:
  # We create a step to create an Output value
  - name: Publish JS filename
    # we can access data from this step via this id
    id: publish
    # a regular a linux shell command that:
    # finds the javascript file in the assets folder
    # you use an identifier key of your choice and store the value in it eg. javascript-file=filename.js
    # it then writes that key=value pair into a special file $GITHUB_OUTPUT created by GitHub in the Environment your Job is running
    run: find dist/assets/*.js -type f -execdir echo 'javascript-file={}' >> $GITHUB_OUTPUT ';'
```

- `find`: find is a command used to search for files and directories in a specified location.

- `dist/assets/*.js`: This is the search path for the find command. It's looking for files with a `.js` extension in the `dist/assets` directory.

- `-type f`: This is an option for the find command. It specifies that only regular files should be considered, excluding directories and other types of files.

- `-execdir`: This is another option for the find command. It is used to execute a command in the directory where the file is found. This is useful when you want to perform an action on each file individually.

- `echo 'javascript-file={}' >> $GITHUB_OUTPUT`: This is the command that is executed for each found file. It uses `echo` to print a message to the standard output, where `{}` is a placeholder that will be replaced by the name of the found file. The output is then appended to a file or variable named `$GITHUB_OUTPUT`

- `;` is used to terminate the `-execdir` option for the `find` command. It tells `find` that the command provided for `-execdir` is complete. In Linux, the semicolon `;` is often used to separate multiple commands on a single line.

- An older syntax (deprecated) for this was `find dist/assets/*.js -type f -execdir echo '::set-output name=javascript-file::{}' ';'`

## Using Job Outputs In Other Jobs

- We can use the GitHub Context, and specifically the `needs` object
- The `needs` object contains the Outputs of all Jobs that are defined as a Dependency of the current Job.
- So we use `needs.(other job name).outputs.(output-identifier)`
- Now we have successfully passed an Output from the `build` Job to the `deploy` Job

```yml
deploy:
  needs: build
  steps:
    - name: Output JS filename
      run: echo "${{ needs.build.outputs.javascript-file }}"
```

## The Need For Dependency Caching

## Caching Dependencies in Practice

## Using & Invalidating Caches

## Module Summary
